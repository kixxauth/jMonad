<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr" id="html">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>jMonad Test Suite</title>
  <link rel="Stylesheet" media="screen" type="text/css"
        href="http://github.com/jquery/qunit/raw/master/qunit/qunit.css" />
  <script type="text/javascript">

// Cross platform event listener.
function addEvent(elem, name, cb) {
  if (typeof elem.addEventListener === "function") {
    elem.addEventListener(name, cb, false);
  }
  else if (typeof elem.attachEvent === "function") {
    elem.attachEvent("on" +type, cb);
  }
  else {
    throw new Error("No event listener method available on DOM.");
  }
}

window.addEventListener("load",
function (load_event, undef) {

  // A shortcut to the jMonad initializer, and the returned monad constructor function.
  var jM, M;

  // We have not included jMonad.js with a script tag or
  // Components.utils.import(), so there should not be a jMonad free variable
  // floating around anywhere.
  test("Global `jMonad` does not exist.", 3, function () {
      
      // jMonad is not attached to the window object
      ok(window.jMonad === undef, "`jMonad` is undefined.");
      equals(window.jMonad, undef, "`jMonad` equals undefined.");

      // Trying to access jMonad as a global will raise a 'ReferenceError'.
      var x;
      try {
        x === jMonad;
      } catch (e) {
      equals(e.name, "ReferenceError",
        "`var x === jMonad` raises 'ReferenceError' exception.");
      }

    });

  // If we are loaded in an envirement without Mozilla chrome privileges,
  // (which would be most of them) we do not want to run the Mozilla JSM
  // complience tests.
  try {

    // Attempting to accecc XPCComponents will raise an error,
    // resulting in skipping the tests in this try block.
    Components.utils;

    /**
     * This documentation is copied from: 
     * http://mxr.mozilla.org/mozilla-central/source/js/src/xpconnect/idl/xpccomponents.idl
     * ------------------------------------------------------------------------------------
     *
     * import is designed to be called from JavaScript only.
     *
     * Synchronously loads and evaluates the js file located at
     * 'registryLocation' with a new, fully privileged global object.
     *
     * If 'targetObj' is specified and equal to null, returns the
     * module's global object. Otherwise (if 'targetObj' is not
     * specified, or 'targetObj' is != null) looks for a property
     * 'EXPORTED_SYMBOLS' on the new global object. 'EXPORTED_SYMBOLS'
     * is expected to be an array of strings identifying properties on
     * the global object.  These properties will be installed as
     * properties on 'targetObj', or, if 'targetObj' is not specified,
     * on the caller's global object. If 'EXPORTED_SYMBOLS' is not
     * found, an error is thrown.
     *
     * @param resourceURI A resource:// URI string to load the module from.
     * @param targetObj  the object to install the exported properties on.
     *        If this parameter is a primitive value, this method throws
     *        an exception.
     * @returns the module code's global object.
     *
     * The implementation maintains a hash of registryLocation->global obj.
     * Subsequent invocations of importModule with 'registryLocation'
     * pointing to the same file will not cause the module to be re-evaluated,
     * but the symbols in EXPORTED_SYMBOLS will be exported into the
     * specified target object and the global object returned as above.
     *
     * (This comment is duplicated from xpcIJSModuleLoader.)
     */
    test("Import jMonad.", 3, function () {
        var module, p, count = 0;

        // The jMonad module is designed to be imported into the Mozilla module
        // system by passing null as the second argument to import(). Since the
        // jMonad module does not contain an EXPORTED_SYMBOLS array, it will
        // raise an exception if it is not imported this way.
        try {
          module = Components.utils.import("resource://chrometest/resources/jMonad.js");
        } catch (e) {
          // 
          equals(e.toString(),
            "Error: resource://chrometest/resources/jMonad.js - EXPORTED_SYMBOLS is not an array.",
            "An exception is raised.");
        }

        // The correct way to import.
        module = Components.utils.import("resource://chrometest/resources/jMonad.js", null);

        // The module object should have two properties,
        // the QueryInterface function and the initializer function for jMonad itself.
        for (p in module) {
          count += 1;
        }
        equals(count, 2, "The imported module has two properties.");

        // The jMonad initializer is function.
        equals(typeof module.jMonad, "function",
            "The imported module has the jMonad initializer function.");

        // Make a shortcut for testing.
        jM = module.jMonad;

      });

  } catch (e) {

    // If Components.utils throws an error, we are not testing jMonad.js as a
    // Mozilla JSM. We'll move ahead by loading the script tag dynamically for
    // the normal browser tests.
    test("Dynamically add the jMonad &lt;script&gt; tag.", 4, function () {

        var timeout;

        // Set the global jMonad symbol so we can test it later with jMonad.noConflict();
        jMonad = 1;

        // We are going to dynamically set the src attribute on a script tag to
        // load the jMonad.js script. To test the script correcty, we need to
        // place the tests inside a load event handler placed on the script tag.
        addEvent(document.getElementById("dynoscript"), "load",
          function () {

            equals(typeof jMonad, "function", "jMonad() is now in the global scope.");
            ok(window.jMonad === jMonad, "We also have window.jMonad().");

            // Set the global we created at the top with .noConflict() and return
            // window.jMonad back to 1.
            jM = jMonad.noConflict();
            equals(typeof jM, "function", "jMonad is now jM in the global scope.");
            equals(jMonad, 1, "window.jMonad is back to what it was before.");

            // Start the testrunner again.
            start();

          });
        document.getElementById("dynoscript").src = "../src/jMonad.js";

        // Block the test runner while we wait for the script to be loaded.
        stop();

      });
  }

  // The jMonad application is built with a call to the jMonad initializer function.
  test("jMonad() initializer", 3, function () {

      // Assign the global we set up at the top of this test module by calling
      // the jMonad initializer.
      M = jM();

      // M is now the monad constructor function.
      equals(typeof M, "function", "M() has been built.");

      // Contruct two monads, ma, and mb.
      var ma = M("monad name");
      var mb = M("monad name");

      // Since they were both created with the same name, jMonad simply loaded
      // ma into mb instead of re-creating it.
      ok(mb === ma, "Monads built with the constructor are cached by name.");

      // However, we can still construct a new monad by passing a different
      // name to the constructor.
      var mc = M("another monad");
      ok((mb != mc && ma != mc),
        "Passing a different name to a constructor yields a new monad.");

    });

  /*

  test(".log()", 2, function () {
      ok(M.log() === M,
        "Static .log() is available and returns the monad constructor.");

      var m = M("log test");
      ok(m.log() === m,
        "Dynamic .log() is available and returns the monad.");
    });

  test(".extend()", 12, function () {

      equals(typeof M.extend, "function", ".extend() is a function.");

      var m = M(".extend() test");
      equals(typeof m.extend, "undefined", "monad.extend() does not exist.");

      var x = {y: function () {}, a: 1};
      var y = {z: function () {}, a: 2};
      ok(M.extend(x).extend(y) === M,
        "Static .extend() returns the monad constructor for chaining.");
      M.observeOnce("jMonad.warning", function (warning) {
          equals(warning, "Naming collision in extend() for 'a'.",
            "Warning issued for clobbering with extend().");
        });

      m = M(".extend() test");
      equals(typeof m.y, "undefined", "Cached monad not extended with y.");
      equals(typeof m.a, "undefined", "Cached monad not extended with a.");
      equals(typeof m.z, "undefined", "Cached monad not extended with z.");

      m = M("another .extend() test");
      equals(typeof m.y, "function", "New monad extended with y.");
      ok(m.y != x.y, "Extended y has been wrapped by another function.");
      equals(m.a, 1, "New monad extended with a == 1, not a == 2.");
      equals(typeof m.z, "function", "New monad extended with z.");
      ok(m.z != y.z, "Extended y has been wrapped by another function.");

    });

  test(".extend()ed methods.", 16, function () {

      dump(" \n  ### extend tests ###\n\n");

      var arg = [1,2,3], m;

      function a (f, g, h) {
        equals(typeof f, "function", "Continuation passed.");
        equals(g, 1, "Arg 0 passed.");
        ok(h === arg, "Arg 1 passed.");
        ok(this === m, "`this` points to the monad object.");
        f();
      }

      function b (g, h, f) {
        equals(typeof f, "undefined", "Continuation NOT passed.");
        equals(g, 1, "Arg 0 passed.");
        ok(h === arg, "Arg 1 passed.");
        ok(this === m, "`this` points to the monad object.");
      }
      b.non_blocking = true;

      function c (f, g) {
        ok(false, "c() should never be called.");
      }

      function d (f, g) {
        ok(false, "d() should never be called.");
      }
      d.non_blocking = true;

      function Foo() {
        this.x = a;
        this.y = 0;
        this.z = b;
      }
      Foo.prototype = {e:1, f:c, g:d};

      // Create a new monad contructor that has not already been extended.
      M = jM();
      M.extend(new Foo());

      m = M("extending monad");
      equals(typeof m.e, "undefined", "Not extended with prototype.e");
      equals(typeof m.f, "undefined", "Not extended with prototype.f");
      equals(typeof m.g, "undefined", "Not extended with prototype.g");
      equals(m.y, 0, "Extended with y");
      m.x(1, arg).z(1, arg).x(1, arg);

      dump(" \n  >>> END extend tests <<<\n\n");

    });

  test("static signals", 14, function () {
      // Create a new monad contructor that has not already been extended.
      var M = jM();

      equals(typeof M.check("test"), "undefined",
        "First .check() is undefined.");

      var vA = 1;
      var vB = {};

      function ob(a, b) {
        equals(a, vA, "First arg.");
        ok(b === vB, "Second arg.");
        ok(this === M, "`this` points to the monad constructor function.");
      }

      function mu() {
        ok(this === M, "`this` points to the monad constructor function.");
      }

      var m = M.observe("test", mu)
        .observeOnce("test", ob)
        .broadcast("test", vA, vB);

      same(M.check("test"), [vA, vB], "Second .check()");
      ok(m === M, ".broadcast() returns the monad constructor function.");

      M.broadcast("test", 44)
        .ignore("test", mu)
        .broadcast("new", 77);
      same(M.check("test"), [44], "Third .check()");
      same(M.check("new"), [77], "Fourth .check()");

      M.observe("test", "new",
          (function () {
             var called = 0;

             return function (val) {
                 called += 1;
                 if (called === 1) {
                   equals(val, 44, "First call is 44.");
                 } else if (called === 2) {
                   equals(val, 77, "Second call is 77.");
                 } else {
                   ok(false, "Should not be called a 3rd time.");
                 }
               };
           }()));

      M.observe("na", function (x) {
            equals(typeof x, "undefined", "No data passed.");
          })
        .broadcast("na");

      M.observeOnce("jMonad.warning", function (msg) {
            ok(false, "No warning is issued if "+
                      "no callback function is passed to observe.");
          });
      M.observe("signal", "message");

      M.observe("undef", function (u) {
            equals(typeof u, "undefined", "no value for undef");
          })
        .broadcast("undef");

    });

  test(".push() and .block()", 7, function () {
      M = jM();

      M("push")
        .push()
        .push(function (a) { equals(a, 1, "pushed function called"); }, 1)
        .push(function (a) { equals(a, 2, "second function called"); }, 2);

      M.observeOnce("jMonad.warning", function (message) {
          equals(message, "A non-function was passed as "+
                          "the first parameter to .push()");
        });

      M.observe("home", function (a) {
          equals(a, 1, "'home' must not be broadcast more than once.")
        });
      M("block")
        .block()
        .block(function (cc, a) {
          cc();
          equals(a, 1, "first block function called");
         }, 1)
        .broadcast("home", 1)
        .block(function (cc, a) { equals(a, 2, "second block function called"); }, 2)
        .broadcast("home", 2);

      M.observeOnce("jMonad.warning", function (message) {
          equals(message, "A non-function was passed as "+
                          "the first parameter to .block()");
        });
    });

  test(".wait()", 4, function () {
      stop();
      M = jM();
      var mark = new Date().getTime();
      M(1)
        .wait("one", 300, function () {
            // We never fire the "one" event.
            var end = new Date().getTime();
            var diff = end - mark;
            ok(270 < diff && diff < 310, "Wait elapsed "+ (end - mark));

            ok(this === M(1), "`this' is bound to the current monad.");

            // Even though we broadcast "one" here, wait will ignore it.
            M.broadcast("one", 1);
          })
        .push(function () {
            var end = new Date().getTime();
            var diff = end - mark;
            ok(270 < diff && diff < 310, "Wait elapsed "+ (end - mark));
            ok(this === M(1), "`this' is bound to the current monad.");
            start();
          });
    });

  test("waitAnd()", 6, function () {
      stop();
      M = jM();
      var mark = new Date().getTime();

      M.broadcast("one", 1);
      M(1)
        .observe("one", function (v) {
            equals(v, 1, "Signal was broadcast.");
          })
        .waitAnd("one", 300, function () {
            var end = new Date().getTime();
            var diff = end - mark;
            ok(270 < diff && diff < 310, "Wait elapsed "+ (end - mark));

            ok(this === M(1), ".waitAnd() `this' is bound to the current monad.");

            // Even though we broadcast "one" here, wait will ignore it.
            M.broadcast("one", 1);
          })
        .push(function () {
            var end = new Date().getTime();
            var diff = end - mark;
            ok(270 < diff && diff < 310, "Wait elapsed "+ (end - mark));
            ok(this === M(1), ".push() `this' is bound to the current monad.");
            start();
          });
    });

  test("chain", 18, function () {
      stop();
      M = jM();

      var mark = new Date().getTime();
      var count = 1;

      setTimeout(function () {
          M.broadcast("wait-over");
        }, 200);

      function observer(n) {
        ok(true, "main fired "+ n +" times.");
      }

      var m = M("chain")
        .observe("main", observer)
        .broadcast("main", count)
        .block(function (done) {
            M.log(" - > blocker");
            equals(count, 1, "count is 1.");
            setTimeout(function () {
                equals(count, 1, "count is 1.");
                count += 1;
                M.broadcast("main", count);
                done();
              }, 0);
          })
        .push(function () {
            M.log(" - > push");
            equals(count, 2, "push() count is 2.");
            count += 1;
            M.broadcast("main", count);
          })
        .observeOnce("main", function (n) {
            M.log(" - > observe");
            equals(count, 3, "observeOnce() count is 3.");
          })
        .wait("wait-over", 300, function() {
            equals(count, 3, "wait() count is 3.");
            count += 1;
            M.broadcast("main", count);
            var now = new Date().getTime();
            var x = now - mark;
            ok((190 < x < 210), "wait()");
          })
        .push(function () {
            equals(count, 4, "push() count is 4");
          })
        .waitAnd(300, "wait-over", function () {
            equals(count, 4, "count is 4.");
            count += 1;
            M.broadcast("main", count);
            var now = new Date().getTime();
            var x = now - mark;
            ok((490 < x < 510), "waitAnd()");
          })
        .push(function () {
            equals(count, 5, "push() count is 5");
          })
        .ignore("main", observer)
        .observe("main", function (n) {
            equals(n, 5, "last count is 5");
          })
        .broadcast("main", 5) // count is still at 1 at this point
        .push(function () {
            M.log(" - > last");
            ok(this === m, "`this` still maps to m");
            start();
          });
    });
  */

}, false);
  </script>
  <script type="text/javascript" src="http://github.com/jquery/qunit/raw/master/qunit/qunit.js"></script>
  <script id="dynoscript" type="text/javascript"></script>
</head>

<body id="body">
  <h1 id="qunit-header">jMonad Test Suite</h1>
  <h2 id="qunit-banner"></h2>
  <div id="qunit-testrunner-toolbar"></div>
  <h2 id="qunit-userAgent"></h2>
  <ol id="qunit-tests"></ol>
</body>
</html>
